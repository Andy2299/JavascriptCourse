<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f2f6ff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#2B2830" />
    <title>Tipos - TypeScript</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../../prism.css">
</head>

<body>
    <div class="container" id="container">
        <div class="section">
            <a class="back-button" href="/typescript/typescript.html">
                < Back</a> <h1>Tipos</h1>
                    <p class="caption">Introducción a los tipos de TypeScript</p>
                    <hr class="separator">
                    <p>En esta sección vamos a ver como TypeScript gestiona los tipos y como podemos usar una de las características más importantes de este lenguaje.</p>
<h2 id="type-annotation">Type Annotation</h2>
<p>La funcionalidad principal de TypeScript es añadir tipos a elementos de JavaScript como variables, funciones, objetos... Para ello, usa la sintaxis <code>elemento: tipo</code> para asignar los tipos que hayamos definido. Esto es conocido como <strong>type annotation</strong>. Una vez que un <em>identificador</em> es anotado con un tipo, <strong>solo podrá usarse con ese tipo</strong>. Si se usa ese identificador con un tipo diferente, el compilador de TypeScript lanzará un error.</p>
<p>Si no se declara el tipo desde el principio TypeScript lo inferirá automáticamente, aplicando las mismas características que con los tipos explícitos. Si se quiere obviar esta funcionalidad, se puede asignar el tipo <strong>any</strong> a cualquier identificador para usarlo de la forma en la que estamos habituados en JavaScript.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> student: <span class="hljs-built_in">string</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// TypeScript error</span>

<span class="hljs-keyword">let</span> helloWorld: <span class="hljs-built_in">any</span> = <span class="hljs-string">"Hello world"</span> <span class="hljs-comment">// Will compile</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">talkFunc</span>(<span class="hljs-params">phrase: <span class="hljs-built_in">string</span></span>) </span>{
    <span class="hljs-built_in">console</span>.log(phrase);
}

<span class="hljs-keyword">let</span> phrase = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">//talkFunc(phrase); // TypeScript error</span>
talkFunc(<span class="hljs-string">"Hello world"</span>);
</code></pre>
<h2 id="categor-a-de-tipos">Categoría de tipos</h2>
<h3 id="tipos-primitivos">Tipos primitivos</h3>
<p>JavaScript tiene tres tipos primitivos: <code>string</code>, <code>number</code> y <code>boolean</code>. Cada uno de ellos tiene un tipo en TypeScript:</p>
<ul>
<li><code>string</code>: Representa las cadenas de JavaScript, con valores como <code>&quot;Hola mundo&quot;</code>.</li>
<li><code>number</code>: Corresponde a los números de JavaScript. Como recordaréis, JavaScript no tiene diferentes valores como <em>int</em> o <em>float</em>, simplemente tenemos <code>number</code>.</li>
<li><code>boolean</code>: Es para los valores booleanos <code>true</code> y <code>false</code>.</li>
</ul>
<p>También existen los tipos <code>String</code>, <code>Number</code> y <code>Boolean</code> <strong>con mayúsculas</strong> se refiere a tipos nativos de TypeScript, es legal su uso pero raramente son necesarios.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// string</span>
<span class="hljs-keyword">let</span> message: <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello World"</span>;
<span class="hljs-comment">// number</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">sum</span>: number = <span class="hljs-number">2</span>;
<span class="hljs-comment">// optional</span>
<span class="hljs-keyword">let</span> optional: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
</code></pre>
<h3 id="any">Any</h3>
<p>Como hemos dicho arriba, TypeSCript cuenta con un tipo especial llamado <code>any</code>, que se usa como comodín para evitar la comprobación de tipos. Básicamente cualquier elemento al que se le asigna <code>any</code> pasa a comportarse como un elemento JavaScript, al que se le puede asignar cualquier valor independientemente del tipo y así saltarse la comprobación del compilador de TypeScript.</p>
<pre><code class="lang-javascript">let <span class="hljs-literal">any</span>Object: <span class="hljs-literal">any</span> = { name: <span class="hljs-string">"Lucas"</span> };
<span class="hljs-literal">any</span>Object.callEmptyMethod();
<span class="hljs-literal">any</span>Object.otherAttribute;
<span class="hljs-literal">any</span>Object = <span class="hljs-string">"String"</span>;
</code></pre>
<h3 id="tipos-por-referencia">Tipos por referencia</h3>
<p>Además de los tipos primitivos, TypeScript soporta tipos por referencia como <code>arrys</code>, <code>objetos</code> y el tipado de <code>funciones</code>.</p>
<ul>
<li><code>arrays</code>: Estructura ordenada de elementos. En el caso de querer tener una colección de números (<code>[1, 2, 3]</code>), podemos usar tanto la sintaxis <code>number[]</code> como <code>Array&lt;number&gt;</code>.</li>
<li><code>functions</code>: Veremos más adelante el tipado de las funciones, pero por ahora podremos poner un ejemplo de la sintaxis. Una definición de función completa sería <code>let func: (firstArg: number, secondArg: number) =&gt; number = function(firstArg: number, secondArg: number): number {return firstArg + secondArg };</code>.</li>
<li><code>objects</code>: Quitando los primitivos, es el otro tipo de tipo más común en TypeScript. Hablaremos en siguientes secciones, pero por ahora podemos adelantar la sintaxis <code>let newObj: { x: number, y: number} = { x: 10, y: 4 }</code>.</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">// array</span>
<span class="hljs-keyword">let</span> numbers: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];
<span class="hljs-comment">// function</span>
<span class="hljs-keyword">let</span> func: (firstArg: <span class="hljs-built_in">number</span>, secondArg: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">
  firstArg: <span class="hljs-built_in">number</span>,
  secondArg: <span class="hljs-built_in">number</span>
</span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> firstArg + secondArg;
};
<span class="hljs-comment">// object</span>
<span class="hljs-keyword">let</span> newObj: { x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span> } = { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">4</span> };
</code></pre>
<h2 id="union-types">Union Types</h2>
<p>TypeScript permite construir nuevos tipos en base a los ya existentes mediante una serie de operadores. Ahora que sabemos construir tipos, vamos a ver como podemos <strong>combinarlos</strong> para conseguir nuevas funcionalidades.</p>
<p>Un <code>union type</code> está formado por dos o más tipos, representando valores que pueden cualquier otro tipo, cada uno de estos tipos son los <em>union&#39;s member</em>.</p>
<pre><code class="lang-javascript"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">printPhoneNumber</span>(<span class="hljs-attribute">phoneNumber</span>: number | string) {
  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">"Your phone number is "</span> + phoneNumber);
}

<span class="hljs-selector-tag">printPhoneNumber</span>(<span class="hljs-number">612389238</span>);
<span class="hljs-selector-tag">printPhoneNumber</span>(<span class="hljs-string">"637839489"</span>);
<span class="hljs-comment">// printPhoneNumber({ phone: 613892348}); // Error</span>
</code></pre>
<h2 id="type-aliases">Type Aliases</h2>
<p>Ahora que conocemos los union types, podemos usarlos cuando queramos, pero hay <strong>una característica muy útil</strong> de TypeScript para no tener que ir escribiendo siempre las uniones. Suponemos que queremos un argumento que tenga de tipos <code>number | string | boolean</code>. Cada vez que queramos comprobar este tipo único, deberíamos escribir esta cadena, pudiendo llevar a errores si olvidamos algún tipo.</p>
<p>Es por ello que podemos definir alias para identificar estos union types con un nombre característico que le queramos dar.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">type</span> ID = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span>

<span class="hljs-keyword">let</span> myID: ID = <span class="hljs-string">"23789s"</span>;
<span class="hljs-keyword">let</span> myOtherId: ID = <span class="hljs-number">213432423</span>;
</code></pre>
<p>Podemos crear también type aliases compuestos, de diferentes anotaciones de tipos, siendo así que podamos crear definiciones enteras de un tipo.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">type</span> Mail = {
  header: <span class="hljs-built_in">string</span>;
  body: <span class="hljs-built_in">string</span>;
  timestamp: <span class="hljs-built_in">number</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMail</span>(<span class="hljs-params">mail: Mail</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${mail.header}</span> - <span class="hljs-subst">${mail.timestamp}</span>`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`---------------------------------`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${mail.body}</span>`</span>);
}
</code></pre>
<h2 id="type-assertions">Type Assertions</h2>
<p>Hay ocasiones en las que tenemos que hacer una conversión de un tipo, bien porque tenía un valor de <strong>any</strong>, bien porque la librería no tiene tipos definidos o que el elemento es genérico, esto por ejemplo en manipulación del DOM es muy común. Es por ello que existen las <strong>type assertions</strong> que permiten hacer un <strong>cast</strong> del tipo de un elemento.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> myCanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"container"</span>) <span class="hljs-keyword">as</span> HTMLDivElement;
</code></pre>


        </div>
    </div>
    <script src="../../prism.js"></script>
    <script type="module" src="index.js"></script>
</body>

</html>